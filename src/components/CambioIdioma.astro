---
import { getCollection } from 'astro:content';

export interface Props {
  lang: 'es' | 'eu';
}

// Idiomas que manejas
const supported = ['es', 'eu'] as const;

// Ruta actual (p.ej. "/es/blog/primer-post" → "/blog/primer-post")
const rawPath = Astro.url.pathname;

// Regex que soporta ambas rutas de detalle:
// - /{lang}/{slug}
// - /{lang}/blog/{slug}
// También cubre /{lang}/ y /{lang}/blog
const m = rawPath.match(/^\/(es|eu)(?:\/(blog))?(?:\/([^/]+))?\/?$/);

const base = (s: string) => s.split('/').pop()!;

let hrefs: Record<'es' | 'eu', string> = { es: '/es', eu: '/eu' };

if (m) {
  const currentLang = m[1] as 'es' | 'eu';
  const section = m[2] || '';            // "blog" o ""
  const maybeSlug = m[3] || '';          // último segmento si hay

  const otherLang = currentLang === 'es' ? 'eu' : 'es';

  // Por defecto: misma ruta cambiando prefijo de idioma
  hrefs.es = `/es${rawPath.replace(/^\/(es|eu)/, '')}`;
  hrefs.eu = `/eu${rawPath.replace(/^\/(es|eu)/, '')}`;

  // ¿Estamos en detalle (hay slug)?
  if (maybeSlug) {
    const all = await getCollection('blog');

    // Intenta localizar el post actual por (lang + basename del slug)
    const current = all.find(
      (e) => e.data.lang === currentLang && base(e.slug) === maybeSlug
    );

    if (current) {
      // Construye el link “actual” normalizado
      hrefs[currentLang] = `/${currentLang}/${base(current.slug)}`;

      // Busca hermano por tkey en el otro idioma (si existe tkey)
      const tkey = current.data.tkey;
      if (tkey) {
        const alt = all.find((e) => e.data.lang === otherLang && e.data.tkey === tkey);
        hrefs[otherLang] = alt
          ? `/${otherLang}/${base(alt.slug)}`
          : `/${otherLang}/blog`; // fallback si no hay traducción
      } else {
        // Sin tkey: último intento ingenuo (mismo basename)
        hrefs[otherLang] =
          section === 'blog'
            ? `/${otherLang}/blog/${maybeSlug}`
            : `/${otherLang}/${maybeSlug}`;
      }
    } else {
      // No identificamos el post (rutas raras): mantener swap simple de prefijo
      hrefs.es = `/es${rawPath.replace(/^\/(es|eu)/, '')}`;
      hrefs.eu = `/eu${rawPath.replace(/^\/(es|eu)/, '')}`;
    }
  }
} else {
  // Ruta fuera del patrón: prefijo simple
  hrefs = { es: `/es${rawPath}`, eu: `/eu${rawPath}` };
}

---
<style>
  .lang-switch {
    list-style: none;
    display: inline-flex;
    padding: 2px;
    border-radius: 10px;
    border: 1px solid;
    background-clip: linear-gradient(to right, blue, green) 1;;
    margin: 0;
  }
  
  .lang-switch li {
  list-style: none;
}
  
  .lang-switch a {
  display: block;
  text-decoration: none;
  padding: 0.25rem 0.5rem;
  border-radius: 10px;
  font-weight: 500;
  color: var(--text-dark);
  background: white; /* color de fondo interior */
  transition: background 0.3s ease, color 0.3s ease;
}
  .lang-switch a.active {
    background: linear-gradient(to right, blue, green);
    color: white;
  }
</style>

<ul class="lang-switch">
  {supported.map((l) => {
    const label = l.toUpperCase();
    const isActive = l === Astro.props.lang;

    // Marca como "disabled" si el link es fallback al índice de blog
    const isFallback = hrefs[l] === `/${l}/blog`;

    return (
      <li>
        <a href={hrefs[l]} class={isActive ? 'active' : ''} aria-disabled={isFallback ? 'true' : 'false'}>
          {label}
        </a>
      </li>
    );
  })}
</ul>
